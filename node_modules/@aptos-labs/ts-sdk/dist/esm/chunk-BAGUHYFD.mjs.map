{"version":3,"sources":["../../src/internal/keyless.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\n/**\n * This file contains the underlying implementations for exposed API surface in\n * the {@link api/keyless}. By moving the methods out into a separate file,\n * other namespaces and processes can access these methods without depending on the entire\n * keyless namespace and without having a dependency cycle error.\n */\nimport { jwtDecode, JwtPayload } from \"jwt-decode\";\nimport { AptosConfig } from \"../api/aptosConfig\";\nimport { postAptosPepperService, postAptosProvingService } from \"../client\";\nimport {\n  AccountAddressInput,\n  EphemeralSignature,\n  Groth16Zkp,\n  Hex,\n  KeylessPublicKey,\n  ZeroKnowledgeSig,\n  ZkProof,\n  getKeylessConfig,\n} from \"../core\";\nimport { HexInput, ZkpVariant } from \"../types\";\nimport { Account, EphemeralKeyPair, KeylessAccount, ProofFetchCallback } from \"../account\";\nimport { PepperFetchRequest, PepperFetchResponse, ProverRequest, ProverResponse } from \"../types/keyless\";\nimport { lookupOriginalAccountAddress } from \"./account\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { FederatedKeylessAccount } from \"../account/FederatedKeylessAccount\";\nimport { MoveVector } from \"../bcs\";\nimport { generateTransaction } from \"./transactionSubmission\";\nimport { InputGenerateTransactionOptions, SimpleTransaction } from \"../transactions\";\n\n/**\n * Retrieves a pepper value based on the provided configuration and authentication details.\n *\n * @param args - The arguments required to fetch the pepper.\n * @param args.aptosConfig - The configuration object for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for the operation.\n * @param args.uidKey - An optional unique identifier key (defaults to \"sub\").\n * @param args.derivationPath - An optional derivation path for the key.\n * @returns A Uint8Array containing the fetched pepper value.\n */\nexport async function getPepper(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  uidKey?: string;\n  derivationPath?: string;\n}): Promise<Uint8Array> {\n  const { aptosConfig, jwt, ephemeralKeyPair, uidKey = \"sub\", derivationPath } = args;\n\n  const body = {\n    jwt_b64: jwt,\n    epk: ephemeralKeyPair.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n    exp_date_secs: ephemeralKeyPair.expiryDateSecs,\n    epk_blinder: Hex.fromHexInput(ephemeralKeyPair.blinder).toStringWithoutPrefix(),\n    uid_key: uidKey,\n    derivation_path: derivationPath,\n  };\n  const { data } = await postAptosPepperService<PepperFetchRequest, PepperFetchResponse>({\n    aptosConfig,\n    path: \"fetch\",\n    body,\n    originMethod: \"getPepper\",\n    overrides: { WITH_CREDENTIALS: false },\n  });\n  return Hex.fromHexInput(data.pepper).toUint8Array();\n}\n\n/**\n * Generates a zero-knowledge proof based on the provided parameters.\n * This function is essential for creating a signed proof that can be used in various cryptographic operations.\n *\n * @param args - The parameters required to generate the proof.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for generating the proof.\n * @param args.pepper - An optional hex input used to enhance security (default is generated if not provided).\n * @param args.uidKey - An optional string that specifies the unique identifier key (defaults to \"sub\").\n * @throws Error if the pepper length is not valid or if the ephemeral key pair's lifespan exceeds the maximum allowed.\n */\nexport async function getProof(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  pepper?: HexInput;\n  uidKey?: string;\n}): Promise<ZeroKnowledgeSig> {\n  const { aptosConfig, jwt, ephemeralKeyPair, pepper = await getPepper(args), uidKey = \"sub\" } = args;\n  if (Hex.fromHexInput(pepper).toUint8Array().length !== KeylessAccount.PEPPER_LENGTH) {\n    throw new Error(`Pepper needs to be ${KeylessAccount.PEPPER_LENGTH} bytes`);\n  }\n  const { maxExpHorizonSecs } = await getKeylessConfig({ aptosConfig });\n  const decodedJwt = jwtDecode<JwtPayload>(jwt);\n  if (typeof decodedJwt.iat !== \"number\") {\n    throw new Error(\"iat was not found\");\n  }\n  if (maxExpHorizonSecs < ephemeralKeyPair.expiryDateSecs - decodedJwt.iat) {\n    throw Error(`The EphemeralKeyPair is too long lived.  It's lifespan must be less than ${maxExpHorizonSecs}`);\n  }\n  const json = {\n    jwt_b64: jwt,\n    epk: ephemeralKeyPair.getPublicKey().bcsToHex().toStringWithoutPrefix(),\n    epk_blinder: Hex.fromHexInput(ephemeralKeyPair.blinder).toStringWithoutPrefix(),\n    exp_date_secs: ephemeralKeyPair.expiryDateSecs,\n    exp_horizon_secs: maxExpHorizonSecs,\n    pepper: Hex.fromHexInput(pepper).toStringWithoutPrefix(),\n    uid_key: uidKey,\n  };\n\n  const { data } = await postAptosProvingService<ProverRequest, ProverResponse>({\n    aptosConfig,\n    path: \"prove\",\n    body: json,\n    originMethod: \"getProof\",\n    overrides: { WITH_CREDENTIALS: false },\n  });\n\n  const proofPoints = data.proof;\n  const groth16Zkp = new Groth16Zkp({\n    a: proofPoints.a,\n    b: proofPoints.b,\n    c: proofPoints.c,\n  });\n\n  const signedProof = new ZeroKnowledgeSig({\n    proof: new ZkProof(groth16Zkp, ZkpVariant.Groth16),\n    trainingWheelsSignature: EphemeralSignature.fromHex(data.training_wheels_signature),\n    expHorizonSecs: maxExpHorizonSecs,\n  });\n  return signedProof;\n}\n\n/**\n * Derives a keyless account by fetching the necessary proof and looking up the original account address.\n * This function helps in creating a keyless account that can be used without managing private keys directly.\n *\n * @param args - The arguments required to derive the keyless account.\n * @param args.aptosConfig - The configuration settings for Aptos.\n * @param args.jwt - The JSON Web Token used for authentication.\n * @param args.ephemeralKeyPair - The ephemeral key pair used for cryptographic operations.\n * @param args.uidKey - An optional unique identifier key for the user.\n * @param args.pepper - An optional hexadecimal input used for additional security.\n * @param args.proofFetchCallback - An optional callback function to handle the proof fetch outcome.\n * @returns A keyless account object.\n */\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<KeylessAccount>;\n\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  jwkAddress: AccountAddressInput;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<FederatedKeylessAccount>;\n\nexport async function deriveKeylessAccount(args: {\n  aptosConfig: AptosConfig;\n  jwt: string;\n  ephemeralKeyPair: EphemeralKeyPair;\n  jwkAddress?: AccountAddressInput;\n  uidKey?: string;\n  pepper?: HexInput;\n  proofFetchCallback?: ProofFetchCallback;\n}): Promise<KeylessAccount | FederatedKeylessAccount> {\n  const { aptosConfig, jwt, jwkAddress, uidKey, proofFetchCallback, pepper = await getPepper(args) } = args;\n  const proofPromise = getProof({ ...args, pepper });\n  // If a callback is provided, pass in the proof as a promise to KeylessAccount.create.  This will make the proof be fetched in the\n  // background and the callback will handle the outcome of the fetch.  This allows the developer to not have to block on the proof fetch\n  // allowing for faster rendering of UX.\n  //\n  // If no callback is provided, the just await the proof fetch and continue synchronously.\n  const proof = proofFetchCallback ? proofPromise : await proofPromise;\n\n  // Look up the original address to handle key rotations and then instantiate the account.\n  if (jwkAddress !== undefined) {\n    const publicKey = FederatedKeylessPublicKey.fromJwtAndPepper({ jwt, pepper, jwkAddress, uidKey });\n    const address = await lookupOriginalAccountAddress({\n      aptosConfig,\n      authenticationKey: publicKey.authKey().derivedAddress(),\n    });\n\n    return FederatedKeylessAccount.create({ ...args, address, proof, pepper, proofFetchCallback, jwkAddress });\n  }\n\n  const publicKey = KeylessPublicKey.fromJwtAndPepper({ jwt, pepper, uidKey });\n  const address = await lookupOriginalAccountAddress({\n    aptosConfig,\n    authenticationKey: publicKey.authKey().derivedAddress(),\n  });\n  return KeylessAccount.create({ ...args, address, proof, pepper, proofFetchCallback });\n}\n\ninterface JWK {\n  kty: string; // Key type\n  kid: string; // Key ID\n  alg: string; // Algorithm used with the key\n  n: string; // Modulus (for RSA keys)\n  e: string; // Exponent (for RSA keys)\n}\n\ninterface JWKS {\n  keys: JWK[];\n}\n\nexport async function updateFederatedKeylessJwkSetTransaction(args: {\n  aptosConfig: AptosConfig;\n  sender: Account;\n  iss: string;\n  jwksUrl?: string;\n  options?: InputGenerateTransactionOptions;\n}): Promise<SimpleTransaction> {\n  const { aptosConfig, sender, iss, options } = args;\n  const jwksUrl = args.jwksUrl ?? (iss.endsWith(\"/\") ? `${iss}.well-known/jwks.json` : `${iss}/.well-known/jwks.json`);\n  const response = await fetch(jwksUrl);\n  if (!response.ok) {\n    throw new Error(`Failed to fetch JWKS: ${response.status} ${response.statusText}`);\n  }\n  const jwks: JWKS = await response.json();\n  return generateTransaction({\n    aptosConfig,\n    sender: sender.accountAddress,\n    data: {\n      function: \"0x1::jwks::update_federated_jwk_set\",\n      functionArguments: [\n        iss,\n        MoveVector.MoveString(jwks.keys.map((key) => key.kid)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.alg)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.e)),\n        MoveVector.MoveString(jwks.keys.map((key) => key.n)),\n      ],\n    },\n    options,\n  });\n}\n"],"mappings":"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","names":["jwtDecode","getPepper","args","aptosConfig","jwt","ephemeralKeyPair","uidKey","derivationPath","body","Hex","data","postAptosPepperService","getProof","pepper","KeylessAccount","maxExpHorizonSecs","getKeylessConfig","decodedJwt","jwtDecode","json","postAptosProvingService","proofPoints","groth16Zkp","Groth16Zkp","ZeroKnowledgeSig","ZkProof","EphemeralSignature","deriveKeylessAccount","jwkAddress","proofFetchCallback","proofPromise","proof","publicKey","FederatedKeylessPublicKey","address","lookupOriginalAccountAddress","FederatedKeylessAccount","KeylessPublicKey","updateFederatedKeylessJwkSetTransaction","sender","iss","options","jwksUrl","response","jwks","generateTransaction","MoveVector","key"]}