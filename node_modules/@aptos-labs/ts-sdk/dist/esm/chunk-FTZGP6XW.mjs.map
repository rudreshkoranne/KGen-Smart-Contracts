{"version":3,"sources":["../../src/core/crypto/keyless.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { JwtPayload, jwtDecode } from \"jwt-decode\";\nimport { AccountPublicKey, PublicKey } from \"./publicKey\";\nimport { Signature } from \"./signature\";\nimport { Deserializer, Serializable, Serializer } from \"../../bcs\";\nimport { Hex } from \"../hex\";\nimport {\n  HexInput,\n  EphemeralCertificateVariant,\n  AnyPublicKeyVariant,\n  SigningScheme,\n  ZkpVariant,\n  LedgerVersionArg,\n  MoveResource,\n} from \"../../types\";\nimport { EphemeralPublicKey, EphemeralSignature } from \"./ephemeral\";\nimport { bigIntToBytesLE, bytesToBigIntLE, hashStrToField, poseidonHash } from \"./poseidon\";\nimport { AuthenticationKey } from \"../authenticationKey\";\nimport { Proof } from \"./proof\";\nimport { Ed25519PublicKey, Ed25519Signature } from \"./ed25519\";\nimport { Groth16VerificationKeyResponse, KeylessConfigurationResponse } from \"../../types/keyless\";\nimport { AptosConfig } from \"../../api/aptosConfig\";\nimport { getAptosFullNode } from \"../../client\";\nimport { memoizeAsync } from \"../../utils/memoize\";\nimport { AccountAddress } from \"../accountAddress\";\n\nexport const EPK_HORIZON_SECS = 10000000;\nexport const MAX_AUD_VAL_BYTES = 120;\nexport const MAX_UID_KEY_BYTES = 30;\nexport const MAX_UID_VAL_BYTES = 330;\nexport const MAX_ISS_VAL_BYTES = 120;\nexport const MAX_EXTRA_FIELD_BYTES = 350;\nexport const MAX_JWT_HEADER_B64_BYTES = 300;\nexport const MAX_COMMITED_EPK_BYTES = 93;\n\n/**\n * Represents a Keyless Public Key used for authentication.\n *\n * This class encapsulates the public key functionality for keyless authentication,\n * including methods for generating and verifying signatures, as well as serialization\n * and deserialization of the key. The KeylessPublicKey is represented in the SDK\n * as `AnyPublicKey`.\n */\nexport class KeylessPublicKey extends AccountPublicKey {\n  /**\n   * The number of bytes that `idCommitment` should be\n   */\n  static readonly ID_COMMITMENT_LENGTH: number = 32;\n\n  /**\n   * The value of the 'iss' claim on the JWT which identifies the OIDC provider.\n   */\n  readonly iss: string;\n\n  /**\n   * A value representing a cryptographic commitment to a user identity.\n   *\n   * It is calculated from the aud, uidKey, uidVal, pepper.\n   */\n  readonly idCommitment: Uint8Array;\n\n  /**\n   * Constructs an instance with the specified parameters for cryptographic operations.\n   *\n   * @param args - The parameters required to initialize the instance.\n   * @param args.alphaG1 - The hex representation of the alpha G1 value.\n   * @param args.betaG2 - The hex representation of the beta G2 value.\n   * @param args.deltaG2 - The hex representation of the delta G2 value.\n   * @param args.gammaAbcG1 - An array containing two hex representations for gamma ABC G1 values.\n   * @param args.gammaG2 - The hex representation of the gamma G2 value.\n   */\n  // TODO: Fix the JSDoc for the below values\n  constructor(iss: string, idCommitment: HexInput) {\n    super();\n    const idcBytes = Hex.fromHexInput(idCommitment).toUint8Array();\n    if (idcBytes.length !== KeylessPublicKey.ID_COMMITMENT_LENGTH) {\n      throw new Error(`Id Commitment length in bytes should be ${KeylessPublicKey.ID_COMMITMENT_LENGTH}`);\n    }\n    this.iss = iss;\n    this.idCommitment = idcBytes;\n  }\n\n  /**\n   * Get the authentication key for the keyless public key.\n   *\n   * @returns AuthenticationKey - The authentication key derived from the keyless public key.\n   */\n  authKey(): AuthenticationKey {\n    const serializer = new Serializer();\n    serializer.serializeU32AsUleb128(AnyPublicKeyVariant.Keyless);\n    serializer.serializeFixedBytes(this.bcsToBytes());\n    return AuthenticationKey.fromSchemeAndBytes({\n      scheme: SigningScheme.SingleKey,\n      input: serializer.toUint8Array(),\n    });\n  }\n\n  /**\n   * Verifies the validity of a signature for a given message.\n   *\n   * @param args - The arguments for signature verification.\n   * @param args.message - The message that was signed.\n   * @param args.signature - The signature to verify against the message.\n   * @returns true if the signature is valid; otherwise, false.\n   */\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars, class-methods-use-this\n  verifySignature(args: { message: HexInput; signature: KeylessSignature }): boolean {\n    throw new Error(\"Not yet implemented\");\n  }\n\n  /**\n   * Serializes the current instance into a format suitable for transmission or storage.\n   * This function ensures that all relevant fields are properly serialized, including the proof and optional fields.\n   *\n   * @param serializer - The serializer instance used to perform the serialization.\n   * @param serializer.proof - The proof to be serialized.\n   * @param serializer.expHorizonSecs - The expiration horizon in seconds.\n   * @param serializer.extraField - An optional additional field for serialization.\n   * @param serializer.overrideAudVal - An optional override value for auditing.\n   * @param serializer.trainingWheelsSignature - An optional signature for training wheels.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.iss);\n    serializer.serializeBytes(this.idCommitment);\n  }\n\n  /**\n   * Deserializes a ZeroKnowledgeSig object from the provided deserializer.\n   * This function allows you to reconstruct a ZeroKnowledgeSig instance from its serialized form.\n   *\n   * @param deserializer - The deserializer instance used to read the serialized data.\n   * @returns A new instance of ZeroKnowledgeSig.\n   */\n  static deserialize(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Loads a KeylessPublicKey instance from the provided deserializer.\n   * This function is used to deserialize the necessary components to create a KeylessPublicKey.\n   *\n   * @param deserializer - The deserializer used to extract the string and byte data.\n   * @param deserializer.deserializeStr - A method to deserialize a string value.\n   * @param deserializer.deserializeBytes - A method to deserialize byte data.\n   * @returns A new instance of KeylessPublicKey.\n   */\n  static load(deserializer: Deserializer): KeylessPublicKey {\n    const iss = deserializer.deserializeStr();\n    const addressSeed = deserializer.deserializeBytes();\n    return new KeylessPublicKey(iss, addressSeed);\n  }\n\n  /**\n   * Determines if the provided public key is an instance of KeylessPublicKey.\n   *\n   * @param publicKey - The public key to check.\n   * @returns A boolean indicating whether the public key is a KeylessPublicKey instance.\n   */\n  static isPublicKey(publicKey: PublicKey): publicKey is KeylessPublicKey {\n    return publicKey instanceof KeylessPublicKey;\n  }\n\n  /**\n   * Creates a KeylessPublicKey from the JWT components plus pepper\n   *\n   * @param args.iss the iss of the identity\n   * @param args.uidKey the key to use to get the uidVal in the JWT token\n   * @param args.uidVal the value of the uidKey in the JWT token\n   * @param args.aud the client ID of the application\n   * @param args.pepper The pepper used to maintain privacy of the account\n   * @returns KeylessPublicKey\n   */\n  static create(args: {\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n  }): KeylessPublicKey {\n    computeIdCommitment(args);\n    return new KeylessPublicKey(args.iss, computeIdCommitment(args));\n  }\n\n  /**\n   * Creates a KeylessPublicKey instance from a JWT and a pepper value.\n   * This function is useful for generating a public key that can be used for authentication based on the provided JWT claims and pepper.\n   *\n   * @param args - The arguments for creating the KeylessPublicKey.\n   * @param args.jwt - The JSON Web Token to decode.\n   * @param args.pepper - The pepper value used in the key creation process.\n   * @param args.uidKey - An optional key to retrieve the unique identifier from the JWT payload, defaults to \"sub\".\n   * @returns A KeylessPublicKey instance created from the provided JWT and pepper.\n   */\n  static fromJwtAndPepper(args: { jwt: string; pepper: HexInput; uidKey?: string }): KeylessPublicKey {\n    const { jwt, pepper, uidKey = \"sub\" } = args;\n    const jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n    if (typeof jwtPayload.iss !== \"string\") {\n      throw new Error(\"iss was not found\");\n    }\n    if (typeof jwtPayload.aud !== \"string\") {\n      throw new Error(\"aud was not found or an array of values\");\n    }\n    const uidVal = jwtPayload[uidKey];\n    return KeylessPublicKey.create({ iss: jwtPayload.iss, uidKey, uidVal, aud: jwtPayload.aud, pepper });\n  }\n\n  /**\n   * Checks if the provided public key is a valid instance by verifying its structure and types.\n   *\n   * @param publicKey - The public key to validate.\n   * @returns A boolean indicating whether the public key is a valid instance.\n   */\n  static isInstance(publicKey: PublicKey) {\n    return (\n      \"iss\" in publicKey &&\n      typeof publicKey.iss === \"string\" &&\n      \"idCommitment\" in publicKey &&\n      publicKey.idCommitment instanceof Uint8Array\n    );\n  }\n}\n\nfunction computeIdCommitment(args: { uidKey: string; uidVal: string; aud: string; pepper: HexInput }): Uint8Array {\n  const { uidKey, uidVal, aud, pepper } = args;\n\n  const fields = [\n    bytesToBigIntLE(Hex.fromHexInput(pepper).toUint8Array()),\n    hashStrToField(aud, MAX_AUD_VAL_BYTES),\n    hashStrToField(uidVal, MAX_UID_VAL_BYTES),\n    hashStrToField(uidKey, MAX_UID_KEY_BYTES),\n  ];\n\n  return bigIntToBytesLE(poseidonHash(fields), KeylessPublicKey.ID_COMMITMENT_LENGTH);\n}\n\n/**\n * Represents a signature of a message signed via a Keyless Account, utilizing proofs or a JWT token for authentication.\n */\nexport class KeylessSignature extends Signature {\n  /**\n   * The inner signature ZeroKnowledgeSignature or OpenIdSignature\n   */\n  readonly ephemeralCertificate: EphemeralCertificate;\n\n  /**\n   * The jwt header in the token used to create the proof/signature.  In json string representation.\n   */\n  readonly jwtHeader: string;\n\n  /**\n   * The expiry timestamp in seconds of the EphemeralKeyPair used to sign\n   */\n  readonly expiryDateSecs: number;\n\n  /**\n   * The ephemeral public key used to verify the signature\n   */\n  readonly ephemeralPublicKey: EphemeralPublicKey;\n\n  /**\n   * The signature resulting from signing with the private key of the EphemeralKeyPair\n   */\n  readonly ephemeralSignature: EphemeralSignature;\n\n  constructor(args: {\n    jwtHeader: string;\n    ephemeralCertificate: EphemeralCertificate;\n    expiryDateSecs: number;\n    ephemeralPublicKey: EphemeralPublicKey;\n    ephemeralSignature: EphemeralSignature;\n  }) {\n    super();\n    const { jwtHeader, ephemeralCertificate, expiryDateSecs, ephemeralPublicKey, ephemeralSignature } = args;\n    this.jwtHeader = jwtHeader;\n    this.ephemeralCertificate = ephemeralCertificate;\n    this.expiryDateSecs = expiryDateSecs;\n    this.ephemeralPublicKey = ephemeralPublicKey;\n    this.ephemeralSignature = ephemeralSignature;\n  }\n\n  serialize(serializer: Serializer): void {\n    this.ephemeralCertificate.serialize(serializer);\n    serializer.serializeStr(this.jwtHeader);\n    serializer.serializeU64(this.expiryDateSecs);\n    this.ephemeralPublicKey.serialize(serializer);\n    this.ephemeralSignature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): KeylessSignature {\n    const ephemeralCertificate = EphemeralCertificate.deserialize(deserializer);\n    const jwtHeader = deserializer.deserializeStr();\n    const expiryDateSecs = deserializer.deserializeU64();\n    const ephemeralPublicKey = EphemeralPublicKey.deserialize(deserializer);\n    const ephemeralSignature = EphemeralSignature.deserialize(deserializer);\n    return new KeylessSignature({\n      jwtHeader,\n      expiryDateSecs: Number(expiryDateSecs),\n      ephemeralCertificate,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  static getSimulationSignature(): KeylessSignature {\n    return new KeylessSignature({\n      jwtHeader: \"{}\",\n      ephemeralCertificate: new EphemeralCertificate(\n        new ZeroKnowledgeSig({\n          proof: new ZkProof(\n            new Groth16Zkp({ a: new Uint8Array(32), b: new Uint8Array(64), c: new Uint8Array(32) }),\n            ZkpVariant.Groth16,\n          ),\n          expHorizonSecs: 0,\n        }),\n        EphemeralCertificateVariant.ZkProof,\n      ),\n      expiryDateSecs: 0,\n      ephemeralPublicKey: new EphemeralPublicKey(new Ed25519PublicKey(new Uint8Array(32))),\n      ephemeralSignature: new EphemeralSignature(new Ed25519Signature(new Uint8Array(64))),\n    });\n  }\n\n  static isSignature(signature: Signature): signature is KeylessSignature {\n    return signature instanceof KeylessSignature;\n  }\n}\n\n/**\n * Represents an ephemeral certificate containing a signature, specifically a ZeroKnowledgeSig.\n * This class can be extended to support additional signature types, such as OpenIdSignature.\n *\n * @extends Signature\n */\nexport class EphemeralCertificate extends Signature {\n  public readonly signature: Signature;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  private readonly variant: EphemeralCertificateVariant;\n\n  constructor(signature: Signature, variant: EphemeralCertificateVariant) {\n    super();\n    this.signature = signature;\n    this.variant = variant;\n  }\n\n  /**\n   * Get the public key in bytes (Uint8Array).\n   *\n   * @returns Uint8Array representation of the public key\n   */\n  toUint8Array(): Uint8Array {\n    return this.signature.toUint8Array();\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.signature.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): EphemeralCertificate {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case EphemeralCertificateVariant.ZkProof:\n        return new EphemeralCertificate(ZeroKnowledgeSig.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for EphemeralCertificate: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a fixed-size byte array of 32 bytes, extending the Serializable class.\n * This class is used for handling and serializing G1 bytes in cryptographic operations.\n *\n * @extends Serializable\n */\nclass G1Bytes extends Serializable {\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 32) {\n      throw new Error(\"Input needs to be 32 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G1Bytes {\n    const bytes = deserializer.deserializeFixedBytes(32);\n    return new G1Bytes(bytes);\n  }\n}\n\n/**\n * Represents a 64-byte G2 element in a cryptographic context.\n * This class provides methods for serialization and deserialization of G2 bytes.\n *\n * @extends Serializable\n */\nclass G2Bytes extends Serializable {\n  data: Uint8Array;\n\n  constructor(data: HexInput) {\n    super();\n    this.data = Hex.fromHexInput(data).toUint8Array();\n    if (this.data.length !== 64) {\n      throw new Error(\"Input needs to be 64 bytes\");\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.data);\n  }\n\n  static deserialize(deserializer: Deserializer): G2Bytes {\n    const bytes = deserializer.deserializeFixedBytes(64);\n    return new G2Bytes(bytes);\n  }\n}\n\n/**\n * Represents a Groth16 zero-knowledge proof, consisting of three proof points in compressed serialization format.\n * The points are the compressed serialization of affine representation of the proof.\n *\n * @extends Proof\n */\nexport class Groth16Zkp extends Proof {\n  /**\n   * The bytes of G1 proof point a\n   */\n  a: G1Bytes;\n\n  /**\n   * The bytes of G2 proof point b\n   */\n  b: G2Bytes;\n\n  /**\n   * The bytes of G1 proof point c\n   */\n  c: G1Bytes;\n\n  constructor(args: { a: HexInput; b: HexInput; c: HexInput }) {\n    super();\n    const { a, b, c } = args;\n    this.a = new G1Bytes(a);\n    this.b = new G2Bytes(b);\n    this.c = new G1Bytes(c);\n  }\n\n  serialize(serializer: Serializer): void {\n    this.a.serialize(serializer);\n    this.b.serialize(serializer);\n    this.c.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): Groth16Zkp {\n    const a = G1Bytes.deserialize(deserializer).bcsToBytes();\n    const b = G2Bytes.deserialize(deserializer).bcsToBytes();\n    const c = G1Bytes.deserialize(deserializer).bcsToBytes();\n    return new Groth16Zkp({ a, b, c });\n  }\n}\n\n/**\n * Represents a container for different types of zero-knowledge proofs.\n *\n * @extends Serializable\n */\nexport class ZkProof extends Serializable {\n  public readonly proof: Proof;\n\n  /**\n   * Index of the underlying enum variant\n   */\n  private readonly variant: ZkpVariant;\n\n  constructor(proof: Proof, variant: ZkpVariant) {\n    super();\n    this.proof = proof;\n    this.variant = variant;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeU32AsUleb128(this.variant);\n    this.proof.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): ZkProof {\n    const variant = deserializer.deserializeUleb128AsU32();\n    switch (variant) {\n      case ZkpVariant.Groth16:\n        return new ZkProof(Groth16Zkp.deserialize(deserializer), variant);\n      default:\n        throw new Error(`Unknown variant index for ZkProof: ${variant}`);\n    }\n  }\n}\n\n/**\n * Represents a zero-knowledge signature, encapsulating the proof and its associated metadata.\n *\n * @extends Signature\n */\nexport class ZeroKnowledgeSig extends Signature {\n  /**\n   * The proof\n   */\n  readonly proof: ZkProof;\n\n  /**\n   * The max lifespan of the proof\n   */\n  readonly expHorizonSecs: number;\n\n  /**\n   * A key value pair on the JWT token that can be specified on the signature which would reveal the value on chain.\n   * Can be used to assert identity or other attributes.\n   */\n  readonly extraField?: string;\n\n  /**\n   * The 'aud' value of the recovery service which is set when recovering an account.\n   */\n  readonly overrideAudVal?: string;\n\n  /**\n   * The training wheels signature\n   */\n  readonly trainingWheelsSignature?: EphemeralSignature;\n\n  constructor(args: {\n    proof: ZkProof;\n    expHorizonSecs: number;\n    extraField?: string;\n    overrideAudVal?: string;\n    trainingWheelsSignature?: EphemeralSignature;\n  }) {\n    super();\n    const { proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal } = args;\n    this.proof = proof;\n    this.expHorizonSecs = expHorizonSecs;\n    this.trainingWheelsSignature = trainingWheelsSignature;\n    this.extraField = extraField;\n    this.overrideAudVal = overrideAudVal;\n  }\n\n  /**\n   * Deserialize a ZeroKnowledgeSig object from its BCS serialization in bytes.\n   *\n   * @param bytes - The bytes representing the serialized ZeroKnowledgeSig.\n   * @returns ZeroKnowledgeSig - The deserialized ZeroKnowledgeSig object.\n   */\n  static fromBytes(bytes: Uint8Array): ZeroKnowledgeSig {\n    return ZeroKnowledgeSig.deserialize(new Deserializer(bytes));\n  }\n\n  serialize(serializer: Serializer): void {\n    this.proof.serialize(serializer);\n    serializer.serializeU64(this.expHorizonSecs);\n    serializer.serializeOptionStr(this.extraField);\n    serializer.serializeOptionStr(this.overrideAudVal);\n    serializer.serializeOption(this.trainingWheelsSignature);\n  }\n\n  static deserialize(deserializer: Deserializer): ZeroKnowledgeSig {\n    const proof = ZkProof.deserialize(deserializer);\n    const expHorizonSecs = Number(deserializer.deserializeU64());\n    const extraField = deserializer.deserializeOptionStr();\n    const overrideAudVal = deserializer.deserializeOptionStr();\n    const trainingWheelsSignature = deserializer.deserializeOption(EphemeralSignature);\n    return new ZeroKnowledgeSig({ proof, expHorizonSecs, trainingWheelsSignature, extraField, overrideAudVal });\n  }\n}\n\n/**\n * Represents the on-chain configuration for how Keyless accounts operate.\n *\n * @remarks\n * This class encapsulates the verification key and the maximum lifespan of ephemeral key pairs,\n * which are essential for the functionality of Keyless accounts.\n */\nexport class KeylessConfiguration {\n  /**\n   * The verification key used to verify Groth16 proofs on chain\n   */\n  // TODO: Rename to verificationKey\n  readonly verficationKey: Groth16VerificationKey;\n\n  /**\n   * The maximum lifespan of an ephemeral key pair.  This is configured on chain.\n   */\n  readonly maxExpHorizonSecs: number;\n\n  constructor(verficationKey: Groth16VerificationKey, maxExpHorizonSecs: number) {\n    this.verficationKey = verficationKey;\n    this.maxExpHorizonSecs = maxExpHorizonSecs;\n  }\n\n  static create(res: Groth16VerificationKeyResponse, maxExpHorizonSecs: number): KeylessConfiguration {\n    return new KeylessConfiguration(\n      new Groth16VerificationKey({\n        alphaG1: res.alpha_g1,\n        betaG2: res.beta_g2,\n        deltaG2: res.delta_g2,\n        gammaAbcG1: res.gamma_abc_g1,\n        gammaG2: res.gamma_g2,\n      }),\n      maxExpHorizonSecs,\n    );\n  }\n}\n\n/**\n * Represents the verification key stored on-chain used to verify Groth16 proofs.\n */\nclass Groth16VerificationKey {\n  // The docstrings below are borrowed from ark-groth16\n\n  /**\n   * The `alpha * G`, where `G` is the generator of G1\n   */\n  readonly alphaG1: G1Bytes;\n\n  /**\n   * The `alpha * H`, where `H` is the generator of G2\n   */\n  readonly betaG2: G2Bytes;\n\n  /**\n   * The `delta * H`, where `H` is the generator of G2\n   */\n  readonly deltaG2: G2Bytes;\n\n  /**\n   * The `gamma^{-1} * (beta * a_i + alpha * b_i + c_i) * H`, where H is the generator of G1\n   */\n  readonly gammaAbcG1: G1Bytes[];\n\n  /**\n   * The `gamma * H`, where `H` is the generator of G2\n   */\n  readonly gammaG2: G2Bytes;\n\n  constructor(args: {\n    alphaG1: HexInput;\n    betaG2: HexInput;\n    deltaG2: HexInput;\n    gammaAbcG1: [HexInput, HexInput];\n    gammaG2: HexInput;\n  }) {\n    const { alphaG1, betaG2, deltaG2, gammaAbcG1, gammaG2 } = args;\n    this.alphaG1 = new G1Bytes(alphaG1);\n    this.betaG2 = new G2Bytes(betaG2);\n    this.deltaG2 = new G2Bytes(deltaG2);\n    this.gammaAbcG1 = [new G1Bytes(gammaAbcG1[0]), new G1Bytes(gammaAbcG1[1])];\n    this.gammaG2 = new G2Bytes(gammaG2);\n  }\n\n  /**\n   * Converts a Groth16VerificationKeyResponse object into a Groth16VerificationKey instance.\n   *\n   * @param res - The Groth16VerificationKeyResponse object containing the verification key data.\n   * @param res.alpha_g1 - The alpha G1 value from the response.\n   * @param res.beta_g2 - The beta G2 value from the response.\n   * @param res.delta_g2 - The delta G2 value from the response.\n   * @param res.gamma_abc_g1 - The gamma ABC G1 value from the response.\n   * @param res.gamma_g2 - The gamma G2 value from the response.\n   * @returns A Groth16VerificationKey instance constructed from the provided response data.\n   */\n  static fromGroth16VerificationKeyResponse(res: Groth16VerificationKeyResponse): Groth16VerificationKey {\n    return new Groth16VerificationKey({\n      alphaG1: res.alpha_g1,\n      betaG2: res.beta_g2,\n      deltaG2: res.delta_g2,\n      gammaAbcG1: res.gamma_abc_g1,\n      gammaG2: res.gamma_g2,\n    });\n  }\n}\n\n/**\n * Retrieves the configuration parameters for Keyless Accounts on the blockchain, including the verifying key and the maximum\n * expiry horizon.\n *\n * @param args - The arguments for retrieving the keyless configuration.\n * @param args.aptosConfig - The Aptos configuration object containing network details.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, the latest version will be used.\n * @returns KeylessConfiguration - The configuration object containing the verifying key and maximum expiry horizon.\n */\nexport async function getKeylessConfig(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfiguration> {\n  const { aptosConfig } = args;\n  return memoizeAsync(\n    async () => {\n      const config = await getKeylessConfigurationResource(args);\n      const vk = await getGroth16VerificationKeyResource(args);\n      return KeylessConfiguration.create(vk, Number(config.max_exp_horizon_secs));\n    },\n    `keyless-configuration-${aptosConfig.network}`,\n    1000 * 60 * 5, // 5 minutes\n  )();\n}\n\n/**\n * Retrieves the KeylessConfiguration set on chain.\n *\n * @param args - The arguments for retrieving the configuration.\n * @param args.aptosConfig - The configuration for connecting to the Aptos network.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns KeylessConfigurationResponse - The response containing the keyless configuration data.\n */\nasync function getKeylessConfigurationResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<KeylessConfigurationResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Configuration\";\n  const { data } = await getAptosFullNode<{}, MoveResource<KeylessConfigurationResponse>>({\n    aptosConfig,\n    originMethod: \"getKeylessConfigurationResource\",\n    path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n\n  return data.data;\n}\n\n/**\n * Retrieves the Groth16VerificationKey set on the blockchain.\n *\n * @param args - The arguments for retrieving the verification key.\n * @param args.aptosConfig - The Aptos configuration object.\n * @param args.options - Optional parameters for the request.\n * @param args.options.ledgerVersion - The ledger version to query; if not provided, it will get the latest version.\n * @returns Groth16VerificationKeyResponse - The response containing the Groth16 verification key data.\n */\nasync function getGroth16VerificationKeyResource(args: {\n  aptosConfig: AptosConfig;\n  options?: LedgerVersionArg;\n}): Promise<Groth16VerificationKeyResponse> {\n  const { aptosConfig, options } = args;\n  const resourceType = \"0x1::keyless_account::Groth16VerificationKey\";\n  const { data } = await getAptosFullNode<{}, MoveResource<Groth16VerificationKeyResponse>>({\n    aptosConfig,\n    originMethod: \"getGroth16VerificationKeyResource\",\n    path: `accounts/${AccountAddress.from(\"0x1\").toString()}/resource/${resourceType}`,\n    params: { ledger_version: options?.ledgerVersion },\n  });\n\n  return data.data;\n}\n"],"mappings":"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","names":["jwtDecode","EPK_HORIZON_SECS","MAX_AUD_VAL_BYTES","MAX_UID_KEY_BYTES","MAX_UID_VAL_BYTES","MAX_ISS_VAL_BYTES","MAX_EXTRA_FIELD_BYTES","MAX_JWT_HEADER_B64_BYTES","MAX_COMMITED_EPK_BYTES","_KeylessPublicKey","AccountPublicKey","iss","idCommitment","idcBytes","Hex","serializer","Serializer","AuthenticationKey","args","deserializer","addressSeed","publicKey","computeIdCommitment","jwt","pepper","uidKey","jwtPayload","jwtDecode","uidVal","KeylessPublicKey","aud","fields","bytesToBigIntLE","hashStrToField","bigIntToBytesLE","poseidonHash","KeylessSignature","_KeylessSignature","Signature","jwtHeader","ephemeralCertificate","expiryDateSecs","ephemeralPublicKey","ephemeralSignature","EphemeralCertificate","EphemeralPublicKey","EphemeralSignature","ZeroKnowledgeSig","ZkProof","Groth16Zkp","Ed25519PublicKey","Ed25519Signature","signature","_EphemeralCertificate","variant","G1Bytes","_G1Bytes","Serializable","data","bytes","G2Bytes","_G2Bytes","_Groth16Zkp","Proof","a","b","c","_ZkProof","proof","_ZeroKnowledgeSig","expHorizonSecs","trainingWheelsSignature","extraField","overrideAudVal","Deserializer","KeylessConfiguration","_KeylessConfiguration","verficationKey","maxExpHorizonSecs","res","Groth16VerificationKey","_Groth16VerificationKey","alphaG1","betaG2","deltaG2","gammaAbcG1","gammaG2","getKeylessConfig","aptosConfig","memoizeAsync","config","getKeylessConfigurationResource","vk","getGroth16VerificationKeyResource","options","resourceType","getAptosFullNode","AccountAddress"]}