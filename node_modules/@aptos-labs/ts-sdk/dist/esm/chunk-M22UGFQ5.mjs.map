{"version":3,"sources":["../../src/account/KeylessAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { JwtPayload, jwtDecode } from \"jwt-decode\";\nimport { HexInput } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport { KeylessPublicKey, ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\n\n/**\n * Account implementation for the Keyless authentication scheme.\n *\n * Used to represent a Keyless based account and sign transactions with it.\n *\n * Use `KeylessAccount.create()` to instantiate a KeylessAccount with a JWT, proof and EphemeralKeyPair.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n *\n * @static\n * @readonly PEPPER_LENGTH - The length of the pepper used for privacy preservation.\n */\nexport class KeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The KeylessPublicKey associated with the account\n   */\n  readonly publicKey: KeylessPublicKey;\n\n  // Use the static constructor 'create' instead.\n\n  /**\n   * Creates an instance of the transaction with an optional proof.\n   *\n   * @param args.proof - An optional ZkProof associated with the transaction.\n   */\n  // TODO: Document rest of parameters\n  private constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n  }) {\n    const publicKey = KeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n  }\n\n  /**\n   * Serializes the transaction data into a format suitable for transmission or storage.\n   * This function ensures that both the transaction bytes and the proof are properly serialized.\n   *\n   * @param serializer - The serializer instance used to convert the transaction data into bytes.\n   */\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.jwt);\n    serializer.serializeStr(this.uidKey);\n    serializer.serializeFixedBytes(this.pepper);\n    this.ephemeralKeyPair.serialize(serializer);\n    if (this.proof === undefined) {\n      throw new Error(\"Cannot serialize - proof undefined\");\n    }\n    this.proof.serialize(serializer);\n  }\n\n  /**\n   * Deserializes the provided deserializer to create a KeylessAccount instance.\n   * This function extracts necessary components such as the JWT, UID key, pepper, ephemeral key pair, and proof from the deserializer.\n   *\n   * @param deserializer - The deserializer instance used to retrieve the serialized data.\n   * @returns A KeylessAccount instance created from the deserialized data.\n   */\n  static deserialize(deserializer: Deserializer): KeylessAccount {\n    const jwt = deserializer.deserializeStr();\n    const uidKey = deserializer.deserializeStr();\n    const pepper = deserializer.deserializeFixedBytes(31);\n    const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n    const proof = ZeroKnowledgeSig.deserialize(deserializer);\n    return KeylessAccount.create({\n      proof,\n      pepper,\n      uidKey,\n      jwt,\n      ephemeralKeyPair,\n    });\n  }\n\n  static fromBytes(bytes: Uint8Array): KeylessAccount {\n    return KeylessAccount.deserialize(new Deserializer(bytes));\n  }\n\n  /**\n   * Creates a KeylessAccount instance using the provided parameters.\n   * This function allows you to set up a KeylessAccount with specific attributes such as address, proof, and JWT.\n   *\n   * @param args - The parameters for creating a KeylessAccount.\n   * @param args.address - Optional account address associated with the KeylessAccount.\n   * @param args.proof - A Zero Knowledge Signature or a promise that resolves to one.\n   * @param args.jwt - A JSON Web Token used for authentication.\n   * @param args.ephemeralKeyPair - The ephemeral key pair used in the account creation.\n   * @param args.pepper - A hexadecimal input used for additional security.\n   * @param args.uidKey - Optional key for user identification, defaults to \"sub\".\n   * @param args.proofFetchCallback - Optional callback function for fetching proof.\n   */\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n  }): KeylessAccount {\n    const { address, proof, jwt, ephemeralKeyPair, pepper, uidKey = \"sub\", proofFetchCallback } = args;\n\n    const jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n    if (typeof jwtPayload.iss !== \"string\") {\n      throw new Error(\"iss was not found\");\n    }\n    if (typeof jwtPayload.aud !== \"string\") {\n      throw new Error(\"aud was not found or an array of values\");\n    }\n    const uidVal = jwtPayload[uidKey];\n    return new KeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss: jwtPayload.iss,\n      uidKey,\n      uidVal,\n      aud: jwtPayload.aud,\n      pepper,\n      jwt,\n      proofFetchCallback,\n    });\n  }\n}\n"],"mappings":"2KAGA,OAAqB,aAAAA,MAAiB,aAsB/B,IAAMC,EAAN,MAAMC,UAAuBC,CAAuB,CAcjD,YAAYC,EAWjB,CACD,IAAMC,EAAYC,EAAiB,OAAOF,CAAI,EAC9C,MAAM,CAAE,UAAAC,EAAW,GAAGD,CAAK,CAAC,EAC5B,KAAK,UAAYC,CACnB,CAQA,UAAUE,EAA8B,CAKtC,GAJAA,EAAW,aAAa,KAAK,GAAG,EAChCA,EAAW,aAAa,KAAK,MAAM,EACnCA,EAAW,oBAAoB,KAAK,MAAM,EAC1C,KAAK,iBAAiB,UAAUA,CAAU,EACtC,KAAK,QAAU,OACjB,MAAM,IAAI,MAAM,oCAAoC,EAEtD,KAAK,MAAM,UAAUA,CAAU,CACjC,CASA,OAAO,YAAYC,EAA4C,CAC7D,IAAMC,EAAMD,EAAa,eAAe,EAClCE,EAASF,EAAa,eAAe,EACrCG,EAASH,EAAa,sBAAsB,EAAE,EAC9CI,EAAmBC,EAAiB,YAAYL,CAAY,EAC5DM,EAAQC,EAAiB,YAAYP,CAAY,EACvD,OAAON,EAAe,OAAO,CAC3B,MAAAY,EACA,OAAAH,EACA,OAAAD,EACA,IAAAD,EACA,iBAAAG,CACF,CAAC,CACH,CAEA,OAAO,UAAUI,EAAmC,CAClD,OAAOd,EAAe,YAAY,IAAIe,EAAaD,CAAK,CAAC,CAC3D,CAeA,OAAO,OAAOZ,EAQK,CACjB,GAAM,CAAE,QAAAc,EAAS,MAAAJ,EAAO,IAAAL,EAAK,iBAAAG,EAAkB,OAAAD,EAAQ,OAAAD,EAAS,MAAO,mBAAAS,CAAmB,EAAIf,EAExFgB,EAAaC,EAAkDZ,CAAG,EACxE,GAAI,OAAOW,EAAW,KAAQ,SAC5B,MAAM,IAAI,MAAM,mBAAmB,EAErC,GAAI,OAAOA,EAAW,KAAQ,SAC5B,MAAM,IAAI,MAAM,yCAAyC,EAE3D,IAAME,EAASF,EAAWV,CAAM,EAChC,OAAO,IAAIR,EAAe,CACxB,QAAAgB,EACA,MAAAJ,EACA,iBAAAF,EACA,IAAKQ,EAAW,IAChB,OAAAV,EACA,OAAAY,EACA,IAAKF,EAAW,IAChB,OAAAT,EACA,IAAAF,EACA,mBAAAU,CACF,CAAC,CACH,CACF","names":["jwtDecode","KeylessAccount","_KeylessAccount","AbstractKeylessAccount","args","publicKey","KeylessPublicKey","serializer","deserializer","jwt","uidKey","pepper","ephemeralKeyPair","EphemeralKeyPair","proof","ZeroKnowledgeSig","bytes","Deserializer","address","proofFetchCallback","jwtPayload","jwtDecode","uidVal"]}