{"version":3,"sources":["../../src/account/FederatedKeylessAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport { JwtPayload, jwtDecode } from \"jwt-decode\";\nimport { HexInput } from \"../types\";\nimport { AccountAddress, AccountAddressInput } from \"../core/accountAddress\";\nimport { ZeroKnowledgeSig } from \"../core/crypto\";\n\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Deserializer, Serializer } from \"../bcs\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\nimport { AbstractKeylessAccount, ProofFetchCallback } from \"./AbstractKeylessAccount\";\n\n/**\n * Account implementation for the FederatedKeyless authentication scheme.\n *\n * Used to represent a FederatedKeyless based account and sign transactions with it.\n *\n * Use `FederatedKeylessAccount.create()` to instantiate a KeylessAccount with a JWT, proof, EphemeralKeyPair and the\n * address the JWKs are installed that will be used to verify the JWT.\n *\n * When the proof expires or the JWT becomes invalid, the KeylessAccount must be instantiated again with a new JWT,\n * EphemeralKeyPair, and corresponding proof.\n */\nexport class FederatedKeylessAccount extends AbstractKeylessAccount {\n  /**\n   * The FederatedKeylessPublicKey associated with the account\n   */\n  readonly publicKey: FederatedKeylessPublicKey;\n\n  // Use the static constructor 'create' instead.\n  private constructor(args: {\n    address?: AccountAddress;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    jwkAddress: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n  }) {\n    const publicKey = FederatedKeylessPublicKey.create(args);\n    super({ publicKey, ...args });\n    this.publicKey = publicKey;\n  }\n\n  serialize(serializer: Serializer): void {\n    if (this.proof === undefined) {\n      throw new Error(\"Cannot serialize - proof undefined\");\n    }\n    serializer.serializeStr(this.jwt);\n    serializer.serializeStr(this.uidKey);\n    serializer.serializeFixedBytes(this.pepper);\n    this.publicKey.jwkAddress.serialize(serializer);\n    this.ephemeralKeyPair.serialize(serializer);\n    this.proof.serialize(serializer);\n  }\n\n  static deserialize(deserializer: Deserializer): FederatedKeylessAccount {\n    const jwt = deserializer.deserializeStr();\n    const uidKey = deserializer.deserializeStr();\n    const pepper = deserializer.deserializeFixedBytes(31);\n    const jwkAddress = AccountAddress.deserialize(deserializer);\n    const ephemeralKeyPair = EphemeralKeyPair.deserialize(deserializer);\n    const proof = ZeroKnowledgeSig.deserialize(deserializer);\n    return FederatedKeylessAccount.create({\n      proof,\n      pepper,\n      jwkAddress,\n      uidKey,\n      jwt,\n      ephemeralKeyPair,\n    });\n  }\n\n  static fromBytes(bytes: Uint8Array): FederatedKeylessAccount {\n    return FederatedKeylessAccount.deserialize(new Deserializer(bytes));\n  }\n\n  static create(args: {\n    address?: AccountAddress;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    jwt: string;\n    ephemeralKeyPair: EphemeralKeyPair;\n    pepper: HexInput;\n    jwkAddress: AccountAddressInput;\n    uidKey?: string;\n    proofFetchCallback?: ProofFetchCallback;\n  }): FederatedKeylessAccount {\n    const { address, proof, jwt, ephemeralKeyPair, pepper, jwkAddress, uidKey = \"sub\", proofFetchCallback } = args;\n\n    const jwtPayload = jwtDecode<JwtPayload & { [key: string]: string }>(jwt);\n    if (typeof jwtPayload.iss !== \"string\") {\n      throw new Error(\"iss was not found\");\n    }\n    if (typeof jwtPayload.aud !== \"string\") {\n      throw new Error(\"aud was not found or an array of values\");\n    }\n    const uidVal = jwtPayload[uidKey];\n    return new FederatedKeylessAccount({\n      address,\n      proof,\n      ephemeralKeyPair,\n      iss: jwtPayload.iss,\n      uidKey,\n      uidVal,\n      aud: jwtPayload.aud,\n      pepper,\n      jwkAddress: AccountAddress.from(jwkAddress),\n      jwt,\n      proofFetchCallback,\n    });\n  }\n}\n"],"mappings":"sPAGA,OAAqB,aAAAA,MAAiB,aAqB/B,IAAMC,EAAN,MAAMC,UAAgCC,CAAuB,CAO1D,YAAYC,EAYjB,CACD,IAAMC,EAAYC,EAA0B,OAAOF,CAAI,EACvD,MAAM,CAAE,UAAAC,EAAW,GAAGD,CAAK,CAAC,EAC5B,KAAK,UAAYC,CACnB,CAEA,UAAUE,EAA8B,CACtC,GAAI,KAAK,QAAU,OACjB,MAAM,IAAI,MAAM,oCAAoC,EAEtDA,EAAW,aAAa,KAAK,GAAG,EAChCA,EAAW,aAAa,KAAK,MAAM,EACnCA,EAAW,oBAAoB,KAAK,MAAM,EAC1C,KAAK,UAAU,WAAW,UAAUA,CAAU,EAC9C,KAAK,iBAAiB,UAAUA,CAAU,EAC1C,KAAK,MAAM,UAAUA,CAAU,CACjC,CAEA,OAAO,YAAYC,EAAqD,CACtE,IAAMC,EAAMD,EAAa,eAAe,EAClCE,EAASF,EAAa,eAAe,EACrCG,EAASH,EAAa,sBAAsB,EAAE,EAC9CI,EAAaC,EAAe,YAAYL,CAAY,EACpDM,EAAmBC,EAAiB,YAAYP,CAAY,EAC5DQ,EAAQC,EAAiB,YAAYT,CAAY,EACvD,OAAON,EAAwB,OAAO,CACpC,MAAAc,EACA,OAAAL,EACA,WAAAC,EACA,OAAAF,EACA,IAAAD,EACA,iBAAAK,CACF,CAAC,CACH,CAEA,OAAO,UAAUI,EAA4C,CAC3D,OAAOhB,EAAwB,YAAY,IAAIiB,EAAaD,CAAK,CAAC,CACpE,CAEA,OAAO,OAAOd,EASc,CAC1B,GAAM,CAAE,QAAAgB,EAAS,MAAAJ,EAAO,IAAAP,EAAK,iBAAAK,EAAkB,OAAAH,EAAQ,WAAAC,EAAY,OAAAF,EAAS,MAAO,mBAAAW,CAAmB,EAAIjB,EAEpGkB,EAAaC,EAAkDd,CAAG,EACxE,GAAI,OAAOa,EAAW,KAAQ,SAC5B,MAAM,IAAI,MAAM,mBAAmB,EAErC,GAAI,OAAOA,EAAW,KAAQ,SAC5B,MAAM,IAAI,MAAM,yCAAyC,EAE3D,IAAME,EAASF,EAAWZ,CAAM,EAChC,OAAO,IAAIR,EAAwB,CACjC,QAAAkB,EACA,MAAAJ,EACA,iBAAAF,EACA,IAAKQ,EAAW,IAChB,OAAAZ,EACA,OAAAc,EACA,IAAKF,EAAW,IAChB,OAAAX,EACA,WAAYE,EAAe,KAAKD,CAAU,EAC1C,IAAAH,EACA,mBAAAY,CACF,CAAC,CACH,CACF","names":["jwtDecode","FederatedKeylessAccount","_FederatedKeylessAccount","AbstractKeylessAccount","args","publicKey","FederatedKeylessPublicKey","serializer","deserializer","jwt","uidKey","pepper","jwkAddress","AccountAddress","ephemeralKeyPair","EphemeralKeyPair","proof","ZeroKnowledgeSig","bytes","Deserializer","address","proofFetchCallback","jwtPayload","jwtDecode","uidVal"]}