import { SigningScheme, HexInput } from '../types/index.mjs';
import { AccountAddress } from '../core/accountAddress.mjs';
import { Serializable, Serializer } from '../bcs/serializer.mjs';
import { FederatedKeylessPublicKey } from '../core/crypto/federatedKeyless.mjs';
import { KeylessPublicKey, ZeroKnowledgeSig, KeylessSignature, ZkProof } from '../core/crypto/keyless.mjs';
import { A as Account } from '../Ed25519Account-DpH9qAcg.mjs';
import { EphemeralKeyPair } from './EphemeralKeyPair.mjs';
import { AccountAuthenticatorSingleKey } from '../transactions/authenticator/account.mjs';
import { AnyRawTransaction, AnyRawTransactionInstance } from '../transactions/types.mjs';
import '../utils/apiEndpoints.mjs';
import '../types/indexer.mjs';
import '../types/generated/operations.mjs';
import '../types/generated/types.mjs';
import '../bcs/deserializer.mjs';
import '../core/common.mjs';
import '../transactions/instances/transactionArgument.mjs';
import '../core/hex.mjs';
import '../publicKey-_tPa99ea.mjs';
import '../core/crypto/signature.mjs';
import '../core/crypto/ephemeral.mjs';
import '../core/crypto/proof.mjs';
import '../types/keyless.mjs';
import '../api/aptosConfig.mjs';
import '../utils/const.mjs';
import '../core/crypto/ed25519.mjs';
import '../core/crypto/privateKey.mjs';
import '../core/crypto/singleKey.mjs';
import '../core/crypto/multiEd25519.mjs';
import '../core/crypto/multiKey.mjs';
import '../bcs/serializable/moveStructs.mjs';
import '../bcs/serializable/movePrimitives.mjs';
import '../bcs/serializable/fixedBytes.mjs';
import '../transactions/instances/rawTransaction.mjs';
import '../transactions/instances/chainId.mjs';
import '../transactions/instances/transactionPayload.mjs';
import '../transactions/instances/identifier.mjs';
import '../transactions/instances/moduleId.mjs';
import '../transactions/typeTag/index.mjs';
import '../transactions/instances/simpleTransaction.mjs';
import '../transactions/instances/multiAgentTransaction.mjs';

/**
 * Account implementation for the Keyless authentication scheme.  This abstract class is used for standard Keyless Accounts
 * and Federated Keyless Accounts.
 */
declare abstract class AbstractKeylessAccount extends Serializable implements Account {
    static readonly PEPPER_LENGTH: number;
    /**
     * The KeylessPublicKey associated with the account
     */
    readonly publicKey: KeylessPublicKey | FederatedKeylessPublicKey;
    /**
     * The EphemeralKeyPair used to generate sign.
     */
    readonly ephemeralKeyPair: EphemeralKeyPair;
    /**
     * The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.
     */
    readonly uidKey: string;
    /**
     * The value of the uidKey claim on the JWT.  This intended to be a stable user identifier.
     */
    readonly uidVal: string;
    /**
     * The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's
     * OIDC registration with the identity provider.
     */
    readonly aud: string;
    /**
     * A value contains 31 bytes of entropy that preserves privacy of the account. Typically fetched from a pepper provider.
     */
    readonly pepper: Uint8Array;
    /**
     * Account address associated with the account
     */
    readonly accountAddress: AccountAddress;
    /**
     * The zero knowledge signature (if ready) which contains the proof used to validate the EphemeralKeyPair.
     */
    proof: ZeroKnowledgeSig | undefined;
    /**
     * The proof of the EphemeralKeyPair or a promise that provides the proof.  This is used to allow for awaiting on
     * fetching the proof.
     */
    readonly proofOrPromise: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;
    /**
     * Signing scheme used to sign transactions
     */
    readonly signingScheme: SigningScheme;
    /**
     * The JWT token used to derive the account
     */
    readonly jwt: string;
    /**
     * An event emitter used to assist in handling asynchronous proof fetching.
     */
    private readonly emitter;
    protected constructor(args: {
        address?: AccountAddress;
        publicKey: KeylessPublicKey | FederatedKeylessPublicKey;
        ephemeralKeyPair: EphemeralKeyPair;
        iss: string;
        uidKey: string;
        uidVal: string;
        aud: string;
        pepper: HexInput;
        proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;
        proofFetchCallback?: ProofFetchCallback;
        jwt: string;
    });
    /**
     * This initializes the asynchronous proof fetch
     * @return
     */
    init(promise: Promise<ZeroKnowledgeSig>): Promise<void>;
    serialize(serializer: Serializer): void;
    /**
     * Checks if the proof is expired.  If so the account must be re-derived with a new EphemeralKeyPair
     * and JWT token.
     * @return boolean
     */
    isExpired(): boolean;
    /**
     * Sign a message using Keyless.
     * @param message the message to sign, as binary input
     * @return the AccountAuthenticator containing the signature, together with the account's public key
     */
    signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey;
    /**
     * Sign a transaction using Keyless.
     * @param transaction the raw transaction
     * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key
     */
    signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey;
    /**
     * Waits for asynchronous proof fetching to finish.
     * @return
     */
    waitForProofFetch(): Promise<void>;
    /**
     * Sign the given message using Keyless.
     * @param message in HexInput format
     * @returns Signature
     */
    sign(message: HexInput): KeylessSignature;
    /**
     * Sign the given transaction with Keyless.
     * Signs the transaction and proof to guard against proof malleability.
     * @param transaction the transaction to be signed
     * @returns KeylessSignature
     */
    signTransaction(transaction: AnyRawTransaction): KeylessSignature;
    /**
     * Note - This function is currently incomplete and should only be used to verify ownership of the KeylessAccount
     *
     * Verifies a signature given the message.
     *
     * TODO: Groth16 proof verification
     *
     * @param args.message the message that was signed.
     * @param args.signature the KeylessSignature to verify
     * @returns boolean
     */
    verifySignature(args: {
        message: HexInput;
        signature: KeylessSignature;
    }): boolean;
}
/**
 * A container class to hold a transaction and a proof.  It implements CryptoHashable which is used to create
 * the signing message for Keyless transactions.  We sign over the proof to ensure non-malleability.
 */
declare class TransactionAndProof extends Serializable {
    /**
     * The transaction to sign.
     */
    transaction: AnyRawTransactionInstance;
    /**
     * The zero knowledge proof used in signing the transaction.
     */
    proof?: ZkProof;
    /**
     * The domain separator prefix used when hashing.
     */
    readonly domainSeparator = "APTOS::TransactionAndProof";
    constructor(transaction: AnyRawTransactionInstance, proof?: ZkProof);
    serialize(serializer: Serializer): void;
    /**
     * Hashes the bcs serialized from of the class. This is the typescript corollary to the BCSCryptoHash macro in aptos-core.
     *
     * @returns Uint8Array
     */
    hash(): Uint8Array;
}
type ProofFetchSuccess = {
    status: "Success";
};
type ProofFetchFailure = {
    status: "Failed";
    error: string;
};
type ProofFetchStatus = ProofFetchSuccess | ProofFetchFailure;
type ProofFetchCallback = (status: ProofFetchStatus) => Promise<void>;
interface ProofFetchEvents {
    proofFetchFinish: (status: ProofFetchStatus) => void;
}

export { AbstractKeylessAccount, type ProofFetchCallback, type ProofFetchEvents, type ProofFetchFailure, type ProofFetchStatus, type ProofFetchSuccess, TransactionAndProof };
