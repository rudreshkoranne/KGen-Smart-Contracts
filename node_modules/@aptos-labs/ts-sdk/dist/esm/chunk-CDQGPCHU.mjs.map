{"version":3,"sources":["../../src/account/AbstractKeylessAccount.ts"],"sourcesContent":["// Copyright Â© Aptos Foundation\n// SPDX-License-Identifier: Apache-2.0\n\nimport EventEmitter from \"eventemitter3\";\nimport { EphemeralCertificateVariant, HexInput, SigningScheme } from \"../types\";\nimport { AccountAddress } from \"../core/accountAddress\";\nimport {\n  AnyPublicKey,\n  AnySignature,\n  KeylessPublicKey,\n  KeylessSignature,\n  EphemeralCertificate,\n  ZeroKnowledgeSig,\n  ZkProof,\n} from \"../core/crypto\";\n\nimport { Account } from \"./Account\";\nimport { EphemeralKeyPair } from \"./EphemeralKeyPair\";\nimport { Hex } from \"../core/hex\";\nimport { AccountAuthenticatorSingleKey } from \"../transactions/authenticator/account\";\nimport { Serializable, Serializer } from \"../bcs\";\nimport { deriveTransactionType, generateSigningMessage } from \"../transactions/transactionBuilder/signingMessage\";\nimport { AnyRawTransaction, AnyRawTransactionInstance } from \"../transactions/types\";\nimport { base64UrlDecode } from \"../utils/helpers\";\nimport { FederatedKeylessPublicKey } from \"../core/crypto/federatedKeyless\";\n\n/**\n * Account implementation for the Keyless authentication scheme.  This abstract class is used for standard Keyless Accounts\n * and Federated Keyless Accounts.\n */\nexport abstract class AbstractKeylessAccount extends Serializable implements Account {\n  static readonly PEPPER_LENGTH: number = 31;\n\n  /**\n   * The KeylessPublicKey associated with the account\n   */\n  readonly publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n\n  /**\n   * The EphemeralKeyPair used to generate sign.\n   */\n  readonly ephemeralKeyPair: EphemeralKeyPair;\n\n  /**\n   * The claim on the JWT to identify a user.  This is typically 'sub' or 'email'.\n   */\n  readonly uidKey: string;\n\n  /**\n   * The value of the uidKey claim on the JWT.  This intended to be a stable user identifier.\n   */\n  readonly uidVal: string;\n\n  /**\n   * The value of the 'aud' claim on the JWT, also known as client ID.  This is the identifier for the dApp's\n   * OIDC registration with the identity provider.\n   */\n  readonly aud: string;\n\n  /**\n   * A value contains 31 bytes of entropy that preserves privacy of the account. Typically fetched from a pepper provider.\n   */\n  readonly pepper: Uint8Array;\n\n  /**\n   * Account address associated with the account\n   */\n  readonly accountAddress: AccountAddress;\n\n  /**\n   * The zero knowledge signature (if ready) which contains the proof used to validate the EphemeralKeyPair.\n   */\n  proof: ZeroKnowledgeSig | undefined;\n\n  /**\n   * The proof of the EphemeralKeyPair or a promise that provides the proof.  This is used to allow for awaiting on\n   * fetching the proof.\n   */\n  readonly proofOrPromise: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n\n  /**\n   * Signing scheme used to sign transactions\n   */\n  readonly signingScheme: SigningScheme;\n\n  /**\n   * The JWT token used to derive the account\n   */\n  readonly jwt: string;\n\n  /**\n   * An event emitter used to assist in handling asynchronous proof fetching.\n   */\n  private readonly emitter: EventEmitter<ProofFetchEvents>;\n\n  // Use the static constructor 'create' instead.\n  protected constructor(args: {\n    address?: AccountAddress;\n    publicKey: KeylessPublicKey | FederatedKeylessPublicKey;\n    ephemeralKeyPair: EphemeralKeyPair;\n    iss: string;\n    uidKey: string;\n    uidVal: string;\n    aud: string;\n    pepper: HexInput;\n    proof: ZeroKnowledgeSig | Promise<ZeroKnowledgeSig>;\n    proofFetchCallback?: ProofFetchCallback;\n    jwt: string;\n  }) {\n    super();\n    const { address, ephemeralKeyPair, publicKey, uidKey, uidVal, aud, pepper, proof, proofFetchCallback, jwt } = args;\n    this.ephemeralKeyPair = ephemeralKeyPair;\n    this.publicKey = publicKey;\n    this.accountAddress = address ? AccountAddress.from(address) : this.publicKey.authKey().derivedAddress();\n    this.uidKey = uidKey;\n    this.uidVal = uidVal;\n    this.aud = aud;\n    this.jwt = jwt;\n    this.emitter = new EventEmitter<ProofFetchEvents>();\n    this.proofOrPromise = proof;\n    if (proof instanceof ZeroKnowledgeSig) {\n      this.proof = proof;\n    } else {\n      if (proofFetchCallback === undefined) {\n        throw new Error(\"Must provide callback for async proof fetch\");\n      }\n      this.emitter.on(\"proofFetchFinish\", async (status) => {\n        await proofFetchCallback(status);\n        this.emitter.removeAllListeners();\n      });\n      // Note, this is purposely not awaited to be non-blocking.  The caller should await on the proofFetchCallback.\n      this.init(proof);\n    }\n    this.signingScheme = SigningScheme.SingleKey;\n    const pepperBytes = Hex.fromHexInput(pepper).toUint8Array();\n    if (pepperBytes.length !== AbstractKeylessAccount.PEPPER_LENGTH) {\n      throw new Error(`Pepper length in bytes should be ${AbstractKeylessAccount.PEPPER_LENGTH}`);\n    }\n    this.pepper = pepperBytes;\n  }\n\n  /**\n   * This initializes the asynchronous proof fetch\n   * @return\n   */\n  async init(promise: Promise<ZeroKnowledgeSig>) {\n    try {\n      this.proof = await promise;\n      this.emitter.emit(\"proofFetchFinish\", { status: \"Success\" });\n    } catch (error) {\n      if (error instanceof Error) {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: error.toString() });\n      } else {\n        this.emitter.emit(\"proofFetchFinish\", { status: \"Failed\", error: \"Unknown\" });\n      }\n    }\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeStr(this.jwt);\n    serializer.serializeStr(this.uidKey);\n    serializer.serializeFixedBytes(this.pepper);\n    this.ephemeralKeyPair.serialize(serializer);\n    if (this.proof === undefined) {\n      throw new Error(\"Cannot serialize - proof undefined\");\n    }\n    this.proof.serialize(serializer);\n  }\n\n  /**\n   * Checks if the proof is expired.  If so the account must be re-derived with a new EphemeralKeyPair\n   * and JWT token.\n   * @return boolean\n   */\n  isExpired(): boolean {\n    return this.ephemeralKeyPair.isExpired();\n  }\n\n  /**\n   * Sign a message using Keyless.\n   * @param message the message to sign, as binary input\n   * @return the AccountAuthenticator containing the signature, together with the account's public key\n   */\n  signWithAuthenticator(message: HexInput): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.sign(message));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Sign a transaction using Keyless.\n   * @param transaction the raw transaction\n   * @return the AccountAuthenticator containing the signature of the transaction, together with the account's public key\n   */\n  signTransactionWithAuthenticator(transaction: AnyRawTransaction): AccountAuthenticatorSingleKey {\n    const signature = new AnySignature(this.signTransaction(transaction));\n    const publicKey = new AnyPublicKey(this.publicKey);\n    return new AccountAuthenticatorSingleKey(publicKey, signature);\n  }\n\n  /**\n   * Waits for asynchronous proof fetching to finish.\n   * @return\n   */\n  async waitForProofFetch() {\n    if (this.proofOrPromise instanceof Promise) {\n      await this.proofOrPromise;\n    }\n  }\n\n  /**\n   * Sign the given message using Keyless.\n   * @param message in HexInput format\n   * @returns Signature\n   */\n  sign(message: HexInput): KeylessSignature {\n    const { expiryDateSecs } = this.ephemeralKeyPair;\n    if (this.isExpired()) {\n      throw new Error(\"EphemeralKeyPair is expired\");\n    }\n    if (this.proof === undefined) {\n      throw new Error(\"Proof not found - make sure to call `await account.waitForProofFetch()` before signing.\");\n    }\n    const ephemeralPublicKey = this.ephemeralKeyPair.getPublicKey();\n    const ephemeralSignature = this.ephemeralKeyPair.sign(message);\n\n    return new KeylessSignature({\n      jwtHeader: base64UrlDecode(this.jwt.split(\".\")[0]),\n      ephemeralCertificate: new EphemeralCertificate(this.proof, EphemeralCertificateVariant.ZkProof),\n      expiryDateSecs,\n      ephemeralPublicKey,\n      ephemeralSignature,\n    });\n  }\n\n  /**\n   * Sign the given transaction with Keyless.\n   * Signs the transaction and proof to guard against proof malleability.\n   * @param transaction the transaction to be signed\n   * @returns KeylessSignature\n   */\n  signTransaction(transaction: AnyRawTransaction): KeylessSignature {\n    if (this.proof === undefined) {\n      throw new Error(\"Proof not found - make sure to call `await account.waitForProofFetch()` before signing.\");\n    }\n    const raw = deriveTransactionType(transaction);\n    const txnAndProof = new TransactionAndProof(raw, this.proof.proof);\n    const signMess = txnAndProof.hash();\n    return this.sign(signMess);\n  }\n\n  /**\n   * Note - This function is currently incomplete and should only be used to verify ownership of the KeylessAccount\n   *\n   * Verifies a signature given the message.\n   *\n   * TODO: Groth16 proof verification\n   *\n   * @param args.message the message that was signed.\n   * @param args.signature the KeylessSignature to verify\n   * @returns boolean\n   */\n  verifySignature(args: { message: HexInput; signature: KeylessSignature }): boolean {\n    const { message, signature } = args;\n    if (this.isExpired()) {\n      return false;\n    }\n    if (!this.ephemeralKeyPair.getPublicKey().verifySignature({ message, signature: signature.ephemeralSignature })) {\n      return false;\n    }\n    return true;\n  }\n}\n\n/**\n * A container class to hold a transaction and a proof.  It implements CryptoHashable which is used to create\n * the signing message for Keyless transactions.  We sign over the proof to ensure non-malleability.\n */\nexport class TransactionAndProof extends Serializable {\n  /**\n   * The transaction to sign.\n   */\n  transaction: AnyRawTransactionInstance;\n\n  /**\n   * The zero knowledge proof used in signing the transaction.\n   */\n  proof?: ZkProof;\n\n  /**\n   * The domain separator prefix used when hashing.\n   */\n  readonly domainSeparator = \"APTOS::TransactionAndProof\";\n\n  constructor(transaction: AnyRawTransactionInstance, proof?: ZkProof) {\n    super();\n    this.transaction = transaction;\n    this.proof = proof;\n  }\n\n  serialize(serializer: Serializer): void {\n    serializer.serializeFixedBytes(this.transaction.bcsToBytes());\n    serializer.serializeOption(this.proof);\n  }\n\n  /**\n   * Hashes the bcs serialized from of the class. This is the typescript corollary to the BCSCryptoHash macro in aptos-core.\n   *\n   * @returns Uint8Array\n   */\n  hash(): Uint8Array {\n    return generateSigningMessage(this.bcsToBytes(), this.domainSeparator);\n  }\n}\n\nexport type ProofFetchSuccess = {\n  status: \"Success\";\n};\n\nexport type ProofFetchFailure = {\n  status: \"Failed\";\n  error: string;\n};\n\nexport type ProofFetchStatus = ProofFetchSuccess | ProofFetchFailure;\n\nexport type ProofFetchCallback = (status: ProofFetchStatus) => Promise<void>;\n\nexport interface ProofFetchEvents {\n  proofFetchFinish: (status: ProofFetchStatus) => void;\n}\n"],"mappings":"+VAGA,OAAOA,MAAkB,gBA2BlB,IAAeC,EAAf,MAAeA,UAA+BC,CAAgC,CAkEzE,YAAYC,EAYnB,CACD,MAAM,EACN,GAAM,CAAE,QAAAC,EAAS,iBAAAC,EAAkB,UAAAC,EAAW,OAAAC,EAAQ,OAAAC,EAAQ,IAAAC,EAAK,OAAAC,EAAQ,MAAAC,EAAO,mBAAAC,EAAoB,IAAAC,CAAI,EAAIV,EAU9G,GATA,KAAK,iBAAmBE,EACxB,KAAK,UAAYC,EACjB,KAAK,eAAiBF,EAAUU,EAAe,KAAKV,CAAO,EAAI,KAAK,UAAU,QAAQ,EAAE,eAAe,EACvG,KAAK,OAASG,EACd,KAAK,OAASC,EACd,KAAK,IAAMC,EACX,KAAK,IAAMI,EACX,KAAK,QAAU,IAAIE,EACnB,KAAK,eAAiBJ,EAClBA,aAAiBK,EACnB,KAAK,MAAQL,MACR,CACL,GAAIC,IAAuB,OACzB,MAAM,IAAI,MAAM,6CAA6C,EAE/D,KAAK,QAAQ,GAAG,mBAAoB,MAAOK,GAAW,CACpD,MAAML,EAAmBK,CAAM,EAC/B,KAAK,QAAQ,mBAAmB,CAClC,CAAC,EAED,KAAK,KAAKN,CAAK,CACjB,CACA,KAAK,cAAgB,EACrB,IAAMO,EAAcC,EAAI,aAAaT,CAAM,EAAE,aAAa,EAC1D,GAAIQ,EAAY,SAAWjB,EAAuB,cAChD,MAAM,IAAI,MAAM,oCAAoCA,EAAuB,aAAa,EAAE,EAE5F,KAAK,OAASiB,CAChB,CAMA,MAAM,KAAKE,EAAoC,CAC7C,GAAI,CACF,KAAK,MAAQ,MAAMA,EACnB,KAAK,QAAQ,KAAK,mBAAoB,CAAE,OAAQ,SAAU,CAAC,CAC7D,OAASC,EAAO,CACVA,aAAiB,MACnB,KAAK,QAAQ,KAAK,mBAAoB,CAAE,OAAQ,SAAU,MAAOA,EAAM,SAAS,CAAE,CAAC,EAEnF,KAAK,QAAQ,KAAK,mBAAoB,CAAE,OAAQ,SAAU,MAAO,SAAU,CAAC,CAEhF,CACF,CAEA,UAAUC,EAA8B,CAKtC,GAJAA,EAAW,aAAa,KAAK,GAAG,EAChCA,EAAW,aAAa,KAAK,MAAM,EACnCA,EAAW,oBAAoB,KAAK,MAAM,EAC1C,KAAK,iBAAiB,UAAUA,CAAU,EACtC,KAAK,QAAU,OACjB,MAAM,IAAI,MAAM,oCAAoC,EAEtD,KAAK,MAAM,UAAUA,CAAU,CACjC,CAOA,WAAqB,CACnB,OAAO,KAAK,iBAAiB,UAAU,CACzC,CAOA,sBAAsBC,EAAkD,CACtE,IAAMC,EAAY,IAAIC,EAAa,KAAK,KAAKF,CAAO,CAAC,EAC/CjB,EAAY,IAAIoB,EAAa,KAAK,SAAS,EACjD,OAAO,IAAIC,EAA8BrB,EAAWkB,CAAS,CAC/D,CAOA,iCAAiCI,EAA+D,CAC9F,IAAMJ,EAAY,IAAIC,EAAa,KAAK,gBAAgBG,CAAW,CAAC,EAC9DtB,EAAY,IAAIoB,EAAa,KAAK,SAAS,EACjD,OAAO,IAAIC,EAA8BrB,EAAWkB,CAAS,CAC/D,CAMA,MAAM,mBAAoB,CACpB,KAAK,0BAA0B,SACjC,MAAM,KAAK,cAEf,CAOA,KAAKD,EAAqC,CACxC,GAAM,CAAE,eAAAM,CAAe,EAAI,KAAK,iBAChC,GAAI,KAAK,UAAU,EACjB,MAAM,IAAI,MAAM,6BAA6B,EAE/C,GAAI,KAAK,QAAU,OACjB,MAAM,IAAI,MAAM,yFAAyF,EAE3G,IAAMC,EAAqB,KAAK,iBAAiB,aAAa,EACxDC,EAAqB,KAAK,iBAAiB,KAAKR,CAAO,EAE7D,OAAO,IAAIS,EAAiB,CAC1B,UAAWC,EAAgB,KAAK,IAAI,MAAM,GAAG,EAAE,CAAC,CAAC,EACjD,qBAAsB,IAAIC,EAAqB,KAAK,OAA0C,EAC9F,eAAAL,EACA,mBAAAC,EACA,mBAAAC,CACF,CAAC,CACH,CAQA,gBAAgBH,EAAkD,CAChE,GAAI,KAAK,QAAU,OACjB,MAAM,IAAI,MAAM,yFAAyF,EAE3G,IAAMO,EAAMC,EAAsBR,CAAW,EAEvCS,EADc,IAAIC,EAAoBH,EAAK,KAAK,MAAM,KAAK,EACpC,KAAK,EAClC,OAAO,KAAK,KAAKE,CAAQ,CAC3B,CAaA,gBAAgBlC,EAAmE,CACjF,GAAM,CAAE,QAAAoB,EAAS,UAAAC,CAAU,EAAIrB,EAI/B,MAHI,OAAK,UAAU,GAGf,CAAC,KAAK,iBAAiB,aAAa,EAAE,gBAAgB,CAAE,QAAAoB,EAAS,UAAWC,EAAU,kBAAmB,CAAC,EAIhH,CACF,EAlPsBvB,EACJ,cAAwB,GADnC,IAAesC,EAAftC,EAwPMqC,EAAN,cAAkCpC,CAAa,CAgBpD,YAAY0B,EAAwCjB,EAAiB,CACnE,MAAM,EAHR,KAAS,gBAAkB,6BAIzB,KAAK,YAAciB,EACnB,KAAK,MAAQjB,CACf,CAEA,UAAUW,EAA8B,CACtCA,EAAW,oBAAoB,KAAK,YAAY,WAAW,CAAC,EAC5DA,EAAW,gBAAgB,KAAK,KAAK,CACvC,CAOA,MAAmB,CACjB,OAAOkB,EAAuB,KAAK,WAAW,EAAG,KAAK,eAAe,CACvE,CACF","names":["EventEmitter","_AbstractKeylessAccount","Serializable","args","address","ephemeralKeyPair","publicKey","uidKey","uidVal","aud","pepper","proof","proofFetchCallback","jwt","AccountAddress","EventEmitter","ZeroKnowledgeSig","status","pepperBytes","Hex","promise","error","serializer","message","signature","AnySignature","AnyPublicKey","AccountAuthenticatorSingleKey","transaction","expiryDateSecs","ephemeralPublicKey","ephemeralSignature","KeylessSignature","base64UrlDecode","EphemeralCertificate","raw","deriveTransactionType","signMess","TransactionAndProof","AbstractKeylessAccount","generateSigningMessage"]}