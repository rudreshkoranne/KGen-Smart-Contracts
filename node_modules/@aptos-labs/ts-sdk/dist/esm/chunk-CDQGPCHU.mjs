import{a as K,b as w}from"./chunk-WSZCPSV4.mjs";import{d as h}from"./chunk-MK2QAHXC.mjs";import{a,b as c}from"./chunk-TPJLAYW6.mjs";import{j as m,k as g,n as P}from"./chunk-FTZGP6XW.mjs";import{b as d}from"./chunk-KM6UXNC7.mjs";import{a as n}from"./chunk-QQIVWB6G.mjs";import{b as f}from"./chunk-KFNDDPOW.mjs";import{d as y}from"./chunk-LEKBJ2EG.mjs";import v from"eventemitter3";var o=class o extends n{constructor(e){super();let{address:r,ephemeralKeyPair:t,publicKey:i,uidKey:F,uidVal:b,aud:E,pepper:A,proof:s,proofFetchCallback:l,jwt:x}=e;if(this.ephemeralKeyPair=t,this.publicKey=i,this.accountAddress=r?d.from(r):this.publicKey.authKey().derivedAddress(),this.uidKey=F,this.uidVal=b,this.aud=E,this.jwt=x,this.emitter=new v,this.proofOrPromise=s,s instanceof P)this.proof=s;else{if(l===void 0)throw new Error("Must provide callback for async proof fetch");this.emitter.on("proofFetchFinish",async T=>{await l(T),this.emitter.removeAllListeners()}),this.init(s)}this.signingScheme=2;let u=f.fromHexInput(A).toUint8Array();if(u.length!==o.PEPPER_LENGTH)throw new Error(`Pepper length in bytes should be ${o.PEPPER_LENGTH}`);this.pepper=u}async init(e){try{this.proof=await e,this.emitter.emit("proofFetchFinish",{status:"Success"})}catch(r){r instanceof Error?this.emitter.emit("proofFetchFinish",{status:"Failed",error:r.toString()}):this.emitter.emit("proofFetchFinish",{status:"Failed",error:"Unknown"})}}serialize(e){if(e.serializeStr(this.jwt),e.serializeStr(this.uidKey),e.serializeFixedBytes(this.pepper),this.ephemeralKeyPair.serialize(e),this.proof===void 0)throw new Error("Cannot serialize - proof undefined");this.proof.serialize(e)}isExpired(){return this.ephemeralKeyPair.isExpired()}signWithAuthenticator(e){let r=new c(this.sign(e)),t=new a(this.publicKey);return new h(t,r)}signTransactionWithAuthenticator(e){let r=new c(this.signTransaction(e)),t=new a(this.publicKey);return new h(t,r)}async waitForProofFetch(){this.proofOrPromise instanceof Promise&&await this.proofOrPromise}sign(e){let{expiryDateSecs:r}=this.ephemeralKeyPair;if(this.isExpired())throw new Error("EphemeralKeyPair is expired");if(this.proof===void 0)throw new Error("Proof not found - make sure to call `await account.waitForProofFetch()` before signing.");let t=this.ephemeralKeyPair.getPublicKey(),i=this.ephemeralKeyPair.sign(e);return new m({jwtHeader:y(this.jwt.split(".")[0]),ephemeralCertificate:new g(this.proof,0),expiryDateSecs:r,ephemeralPublicKey:t,ephemeralSignature:i})}signTransaction(e){if(this.proof===void 0)throw new Error("Proof not found - make sure to call `await account.waitForProofFetch()` before signing.");let r=K(e),i=new p(r,this.proof.proof).hash();return this.sign(i)}verifySignature(e){let{message:r,signature:t}=e;return!(this.isExpired()||!this.ephemeralKeyPair.getPublicKey().verifySignature({message:r,signature:t.ephemeralSignature}))}};o.PEPPER_LENGTH=31;var S=o,p=class extends n{constructor(r,t){super();this.domainSeparator="APTOS::TransactionAndProof";this.transaction=r,this.proof=t}serialize(r){r.serializeFixedBytes(this.transaction.bcsToBytes()),r.serializeOption(this.proof)}hash(){return w(this.bcsToBytes(),this.domainSeparator)}};export{S as a,p as b};
//# sourceMappingURL=chunk-CDQGPCHU.mjs.map